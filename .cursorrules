# Git Behavior - CRITICAL

## Committing Changes

When ready to commit:

1. First, add any NEW files created that are INTENDED TO BE COMMITTED using `git add <specific-file>`
2. Commit using `git commit -a` (normal workflow, commits all modified tracked files) or `git commit <modified files>` (commit only a subset)

## What NOT to do

- NEVER use `git add -A`, `git add .`, or `git add --all`
- NEVER add untracked files - they may be the user's local notes, logs, or temporary data

## What Belongs in the Repo vs. What Doesn't

**Commit these** (needed by users of the software):
- Source code
- Dependency specs and project configuration
- User-facing documentation (how to install, use, set up)

**Do NOT commit these** (developer-only artifacts):
- Personal notes, planning docs, internal architecture docs, TODOs
- Local convenience/wrapper scripts
- One-time setup utilities, API key configuration scripts

**Guiding question**: "Would someone cloning this repo to USE the software need this file?"
- Yes → commit it
- No (it's for the developer's workflow/thinking) → don't commit

**When uncertain about a file, ASK before committing.**

# Debugging - Use Existing Loggers

When adding debug instrumentation:

1. **Use the existing logger** - Classes already have `self.logger`, use it
2. **Use DEBUG level** - `self.logger.debug('[DEBUG] ...')` for temporary instrumentation
3. **Don't invent new logging mechanisms** - No custom file writes, HTTP endpoints, or new logging infrastructure
4. **Remember the runtime environment** - Code may run in Docker, on remote machines, etc. The existing logger already handles this correctly

# Debugging - Revert Failed Fixes

When a fix attempt doesn't work:

1. **Revert the failed change first** - Don't pile hacks on top of failed hacks
2. **Return to the last known state** - Before trying a new approach
3. **One change at a time** - So we know exactly what worked or didn't

# Testing - E2E Before Committing Substantial Changes

This is a multimedia project with GStreamer pipelines, audio/video hardware, and real-time playback. The pytest tests use mocks and fakesinks — they verify logic but don't test the actual pipeline.

Before committing substantial changes (especially to streaming, playback, queue, or pipeline code):

1. Run pytest as a quick sanity check
2. **Ask the user to test end-to-end** — run the actual app, play a song, verify it works
3. Only commit after user confirms e2e testing passes

Don't commit based on pytest alone for changes that could affect the real pipeline.
